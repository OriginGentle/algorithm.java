package com.system.D_weekly.code_2023_02_2_week;

import java.util.Arrays;

/**
 * @author ycb
 * @date 2023/2/12-00:06
 * @desc 给定一个由 n 个节点组成的网络，用 n x n 个邻接矩阵 graph 表示
 * 在节点网络中，只有当 graph[i][j] = 1 时，节点 i 能够直接连接到另一个节点 j。
 * 一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，
 * 且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。
 * 这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。
 * 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。
 * 我们可以从 initial 中删除一个节点，
 * 并完全移除该节点以及从该节点到任何其他节点的任何连接。
 * 请返回移除后能够使 M(initial) 最小化的节点。
 * 如果有多个节点满足条件，返回索引 最小的节点 。
 * initial 中每个整数都不同
 * 测试链接 : https://leetcode.cn/problems/minimize-malware-spread-ii/
 */
public class Code04_MinimizeMalwareSpreadII {

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        boolean[] virus = new boolean[n];
        for (int i : initial) {
            virus[i] = true;
        }

        UnionFind uf = new UnionFind(n);
        // 忽略感染点，建立集合信息
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (graph[i][j] == 1 && !virus[i] && !virus[j]) {
                    uf.union(i, j);
                }
            }
        }

        // infect[i] == -1 ，目前这个集合没有感染源
        // infect[i] == -2 ，目前这个集合已经发现了不只一个感染源
        // infect[i] == x  ，目前这个集合已经发现了一个感染源，是x点
        int[] infect = new int[n];
        Arrays.fill(infect, -1);
        for (int v : initial) { // 枚举所有感染点
            for (int next = 0; next < n; next++) {
                if (v != next && !virus[next] && graph[v][next] == 1) {
                    int f = uf.find(next);
                    if (infect[f] == -1) {
                        infect[f] = v;
                    } else {
                        if (infect[f] != -2 && infect[f] != v) {
                            infect[f] = -2;
                        }
                    }
                }
            }
        }

        int[] cnt = new int[n];
        for (int i = 0; i < n; i++) {
            if (infect[i] >= 0) {
                cnt[infect[i]] += uf.size[i];
            }
        }

        Arrays.sort(initial);
        int ans = initial[0];
        int count = cnt[ans];
        for (int i : initial) {
            if (cnt[i] > count) {
                ans = i;
                count = cnt[i];
            }
        }
        return ans;
    }

    public static class UnionFind {
        public int[] father;
        public int[] size;
        public int[] help;

        public UnionFind(int n) {
            father = new int[n];
            size = new int[n];
            help = new int[n];
            for (int i = 0; i < n; i++) {
                father[i] = i;
                size[i] = 1;
            }
        }

        public int find(int i) {
            int hi = 0;
            while (i != father[i]) {
                help[hi++] = i;
                i = father[i];
            }
            while (hi != 0) {
                father[help[--hi]] = i;
            }
            return i;
        }

        public void union(int i, int j) {
            int fi = find(i);
            int fj = find(j);
            if (fi != fj) {
                if (size[fi] >= size[fj]) {
                    father[fj] = fi;
                    size[fi] += size[fj];
                } else {
                    father[fi] = fj;
                    size[fj] += size[fi];
                }
            }
        }
    }
}
